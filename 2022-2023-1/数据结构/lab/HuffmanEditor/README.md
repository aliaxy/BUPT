# 实验二：哈夫曼编译器

## 实验要求

### 【问题描述】

哈夫曼编码是一种基于最优二叉树的无损编码方案。需要根据字符集和频度的实际统计构建哈夫曼树，然后进行编码和译码。

### 【基本要求】

1. **初始化：** 从终端读入字符集大小n，以及n个字符和n个权值，建立哈夫曼树，并将它存于文件`hfmTree`中
2. **编码：** 利用已经建好的哈夫曼树，对文件`ToBeTran`中的中文进行编码，然后将结果存入文件`CodeFile`中
3. **译码：** 利用已建好的哈夫曼树，对`CodeFile`中的代码进行译码，结果存入`TextFile`中
4. **打印哈夫曼树：** 将建立的哈夫曼树以直观的方式（如凹入表）显示在终端上

### 【测试数据】

用下表给出的字符集和频度的实际统计数据建立哈夫曼树，并实现对报文`“THIS PROGRAM IS MY FAVORITE”`的编码和译码。

| 字符     | 空格  | A     | B     | C     | D     | E     | F     |
| -------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| **频度** | 186   | 64    | 13    | 22    | 32    | 103   | 21    |
| **字符** | **G** | **H** | **I** | **J** | **K** | **L** | **M** |
| **频度** | 15    | 47    | 57    | 1     | 5     | 32    | 20    |
| **字符** | **N** | **O** | **P** | **Q** | **R** | **S** | **T** |
| **频度** | 57    | 63    | 15    | 1     | 48    | 51    | 80    |
| **字符** | **U** | **V** | **W** | **X** | **Y** | **Z** |       |
| **频度** | 23    | 8     | 18    | 1     | 16    | 1     |       |

### 【选做内容】

对一个`512*512`的`lena.bmp`灰度图片进行哈夫曼编码。`BMP`文件由：`BMP`文件头+像素数据组成，灰度图1个像素占用1个字节。`lena.bmp`文件大小是263222字节，包括`1078`字节的头部+`512*512`个像素值

![img](C:/Users/aruve/Documents/BUPT/2022-2023-1/01_数据结构/2_Homework/HuffmanEditor/asset/lena.bmp)

# 实验报告

## 需求分析

1. 根据输入构建一颗哈夫曼树，并保存每个字符编码后的值，输出至文件`hfmTree`中
2. 根据得到的编码表处理`ToBeTran`，对每个字符进行替换，得到编码后的结果`CodeFile`中
3. 根据`CodeFile`中数据，用编码表进行解码处理，输出至`TextFile`中
4. 以凹入表的方式输出哈夫曼树
5. 对位图的每一个像素进行哈夫曼编码

---

## 概要设计

### 主要模块流程

```mermaid
graph LR
	程序输入-->构建哈夫曼树-->构建哈夫曼编码-->保存哈夫曼编码-->对文件进行编码并输出-->对文件进行译码并输出-->打印哈夫曼树
```

```mermaid
graph LR
	读入位图-->构建哈夫曼树-->构建哈夫曼编码-->保存哈夫曼编码
```

### 主要数据结构及接口

#### `huffman.h`

```c++
/* huffman.h */

/* 哈夫曼树的结点 */
typedef struct TNode {
  int w;              // 权值
  unsigned char ch;   // 代表字符 仅对叶子节点有效
  TNode *left, *right;// 左右子树

  TNode() : w(0), ch(0), left(nullptr), right(nullptr){};
  TNode(int w, unsigned char ch) : w(w), ch(ch), left(nullptr), right(nullptr){};
  TNode(TNode *x, TNode *y) : w(x->w + y->w), ch(0), left(x), right(y){};// 便于树的合并
} * huffTree;

/* 优先队列比较函数 小根堆 */
struct cmp {
  bool operator()(TNode *a, TNode *b) { return a->w > b->w;}
};

// 哈夫曼类
class huffman {
 public:     // 公有成员 对外可见
  huffman(); // 构造函数
  ~huffman();// 析构函数

  void createTree(const std::unordered_map<unsigned char, int> &);// 创建哈夫曼树
  void createCode();                                              // 创建哈夫曼编码表
  void saveCodeHex(std::string);            // 存储哈夫曼编码表 源码以十六进制数表示
  void saveCodeChar(std::string);           // 存储哈夫曼编码表 源码以字符表示
  void encodeBmp(std::string, std::string); // 对bmp文件进行编码
  void encodeText(std::string, std::string);// 对文本文件进行编码
  void decode(std::string, std::string);    // 对某文件进行译码
  void showTree();                          // 凹入表输出哈夫曼树

 private:                                   // 公有成员 对外不可见
  huffTree root;                            // 哈夫曼树根节点
  std::map<unsigned char, std::string> keys;// 编码表

  void _createCode(TNode *, std::string);// 创建哈夫曼编码表 内部处理接口
  void _showTree(TNode *, int);          // 凹入表输出哈夫曼树 内部处理接口
};
```

#### `bitmap.h`

```c++
/* bitmap.h */

/* 文件信息头结构 */
typedef struct BITMAPFILEHEADER {
  uint16_t bfType;                 // 必须是BM字符串 对应的十六进制为0x4d42
  uint32_t bfSize;                 // 文件大小 以字节为单位(2-5字节)
  uint16_t bfReserved1;            // 保留 必须设置为0 (6-7字节)
  uint16_t bfReserved2;            // 保留 必须设置为0 (8-9字节)
  uint32_t bfOffBits;              // 从文件头到像素数据的偏移 (10-13字节)
} __attribute__((packed)) FILEHEAD;// 取消内存对齐

/* 图像信息头结构 */
typedef struct BITMAPINFOHEADER {
  uint32_t biSize;         // 此结构体的大小 (14-17字节)
  uint32_t biWidth;        // 图像的宽  (18-21字节)
  uint32_t biHeight;       // 图像的高  (22-25字节)
  uint16_t biPlanes;       // 表示bmp图片的平面数 恒等于1 (26-27字节)
  uint16_t biBitCount;     // 一像素所占的位数 一般为24   (28-29字节)
  uint32_t biCompression;  // 图像数据压缩的类型 0为不压缩。 (30-33字节)
  uint32_t biSizeImage;    // 像素数据所占大小 等于上面文件头结构中bfSize-bfOffBits (34-37字节)
  uint32_t biXPelsPerMeter;// 水平分辨率 用像素/米表示 一般为0 (38-41字节)
  uint32_t biYPelsPerMeter;// 垂直分辨率 用像素/米表示 一般为0 (42-45字节)
  uint32_t biClrUsed;      // 实际使用的彩色表中的颜色索引 0说明使用所有调色板项 (46-49字节)
  uint32_t biClrImportant; // 说明对图象显示有重要影响的颜色索引数 0表示都重要 (50-53字节)
} __attribute__((packed)) INFOHEAD;// 取消内存对齐

/* 图像素信息结构 (调色板) */
typedef struct BITMAPCOLORINfO {
  uint8_t rgbBlue; // 该颜色的蓝色分量 (值范围为0-255)
  uint8_t rgbGreen;// 该颜色的绿色分量 (值范围为0-255)
  uint8_t rgbRed;  // 该颜色的红色分量 (值范围为0-255)
  uint8_t rgbAlpha;// 保留，必须为0
} COLORINFO;

/* 位图类 */
class bitmap {
 public:                                         // 公有成员 对外可见
  bitmap();                                      // 构造函数
  ~bitmap();                                     // 析构函数
  void loadBmp(std::string);                     // 加载位图
  void savePixel();                              // 保存每个像素点的出现频度
  std::unordered_map<uint8_t, int> getPixelCnt();// 获取每个像素点的出现频度

 private:                                   // 私有成员 对外不可见
  const int PIXELSZIE = 256;                // 调色板大小
  FILEHEAD *fileHeader;                     // 文件信息头
  INFOHEAD *infoHeader;                     // 图像信息头
  COLORINFO *colorInfo;                     // 调色板
  uint8_t *pixelInfo;                       // 所有像素点
  std::unordered_map<uint8_t, int> pixelCnt;// 每个像素点的出现频度
};
```

---

## 详细设计

### `huffman.cpp`

#### `void createTree(const std::unordered_map<unsigned char, int> &src);`

> 创建一个小根堆，用`STL`中优先队列和自定义排序结构实现。堆中存储叶子节点，并用`src`中的两个参数进行初始化
>
> 每次从堆中取出两个权值的元素，将他们合并成一个结点，其中新节点的左孩子是权值最小的结点，右孩子是权值次小的结点，再将新节点添加到堆中，一直到堆中只剩下一个元素为止
>
> 此时，堆中的元素即为哈夫曼树的根节点，从而完成建立哈夫曼树的过程

#### `void _createCode(TNode *root, std::string key);`

> 从根节点开始递归处理，初始情况`key`为空字符串，递归左子树时`key + "0"`，递归右子树时`key + "1"`
>
> 当到达叶子节点时，此时的`key`即为该字符所对应的哈夫曼编码的值，存储在该类的编码表`keys`中

#### `void encodeText(std::string src, std::string dest);`

> 从`src`中读取待编码的字符串，并将编码后的结果输出值`dest`中
>
> 每从`src`中读取到一个字符，就根据编码表输出其编码至`dest`中

#### `void encodeBmp(std::string src, std::string dest);`

> 此函数与上一函数作用相同，为`bmp`文件专用

#### `void decode(std::string src, std::string dest);`

> 从`src`中读取待译码的字符串，并将译码后的结果输出至`dest`中
>
> 从`src`中按行读取，每一行一定都是由若干个完整哈夫曼编码组成的
>
> 从根节点开始，若是字符`0`，转移到左子树，若是字符`1`，转移到右子树，直到达到叶子结点，该叶子结点中的字符即为原字符，输出至`dest`中
>
> 重复上述过程，直到遍历完所有的编码

#### `void _showTree(TNode *root, int n);`

> 以凹入表的形式来输出一颗树，参数`n`表示输出的制表符个数
>
> 递归处理右子树`root->left, n + 1`
>
> 输出制表符，并且输出该结点对应的权值，如果是叶子结点，再输出对应字符
>
> 递归处理左子树`root->right, n + 1`

---

### `bitmap.cpp`

#### `void loadBmp(std::string src);`

> 从路径`src`中加载`bmp`图片
>
> 按照字节依次读取文件信息头、图像信息头、调色板和所有像素点

#### `void savePixel();`

> 循环遍历，保存每个像素出现的次数，用`STL`中的`unordered_map`作为哈希表实现

#### `std::unordered_map<uint8_t, int> bitmap::getPixelCnt();`

> 返回该类下的像素统计信息`pixelCnt`

---

## 设计和调试分析

1. 如何保存对应的哈夫曼编码

   > 使用`map`这种哈希表即可实现

2. 凹入表应如何对齐输出

   > 最开始输出的哈夫曼树杂乱无章，毫无规律，十分难看。后来应用了制表符，使得能够整齐打印

3. 位图应该怎么读入

   > 对位图毫无了解，根本不知道从何入手。从网上查阅位图相关资料后，了解了位图的各个部分及其功能。开始着手设计位图的结构体，得到`FILEHEAD INFOHEAD COLORINFO PIXELINFO`
   >
   > 对位图使用二进制文件形式打开，前面一部分是文件信息头、图片信息头、调色板，最后是各个像素排列。于是就可以按照顺序进行一个一个读入了

4. 结构体字节对齐问题

   > 最初读入位图数据的时候，没有考虑到结构体的字节对齐问题，直接进行读入。而位图中的数据都是连续的，从而导致一些数据并没有被保存到预期的位置，甚至可能产生严重问题
   >
   > 查阅资料，发现了可以取消结构体对齐的方式，在`gcc`下，一种是添加`#pragma pack()`，另一种是在声明时添加`__attribute__((packed))`，由于第一种的作用域是整个工程，因此采用了第二种方式来解决

---

## 用户手册 对应用程序的运行使用方式进行说明

1. 在目录`testCase`中添加好用于编码的`ToBeTran`文件，在目录`asset`中添加位图`lena.bmp`文件

2. 运行程序，从终端输入字符集大小n，以及n个字符和n个权值，程序建立哈夫曼树，并输出编码到`./testCase/hfmTree`中
3. 程序对`./testCase/ToBeTran`进行编码，编码结果输出到`./testCase/CodeFile`中
4. 程序对`./testCase/CodeFile`进行译码，译码结果输出到`./testCase/TextFil`中
5. 程序在终端上输出以凹入表显示的哈夫曼树
6. 程序从`./asset/lena.bmp`中读取位图信息，保存文件信息头、图像信息头、调色板和所有像素点，并统计每种像素点个数
7. 根据得到的每种像素点个数建立哈夫曼树，并进行编码，将编码输出至`./testCase/bmpHuffmCode`中
8. 对`./asset/lena.bmp`进行编码，文件输出至`./testCase/bmpCodeFile`

---

## 测试结果

### 测试文件

#### `ToBeTran`

```txt
THIS PROGRAM IS MY FAVORITE
```

#### `lena.bmp`

<img src="./asset/lena.bmp" alt="img" style="zoom:80%;" />

### 程序结果

### `hfmTree`

```txt
 : 111
A: 1010
B: 100000
C: 00000
D: 10110
E: 010
F: 110011
G: 100010
H: 0001
I: 0111
J: 1100001010
K: 11000011
L: 10111
M: 110010
N: 0110
O: 1001
P: 100001
Q: 1100001011
R: 0010
S: 0011
T: 1101
U: 00001
V: 1100000
W: 110001
X: 1100001000
Y: 100011
Z: 1100001001
```

### `CodeFile`

```txt
1101000101110011111100001001010011000100010101011001011101110011111110010100011111110011101011000001001001001111101010
```

### `TextFile`

```txt
THIS PROGRAM IS MY FAVORITE
```

### `Console Output`

```txt
                        186( )
                342
                                080(T)
                        156
                                                021(F)
                                        041
                                                020(M)
                                076
                                                018(W)
                                        035
                                                                005(K)
                                                        009
                                                                                001(Q)
                                                                        002
                                                                                001(J)
                                                                004
                                                                                001(Z)
                                                                        002
                                                                                001(X)
                                                017
                                                        008(V)
        592
                                        032(L)
                                064
                                        032(D)
                        128
                                064(A)
                250
                                063(O)
                        122
                                                016(Y)
                                        031
                                                015(G)
                                059
                                                015(P)
                                        028
                                                013(B)
1000
                                057(I)
                        114
                                057(N)
                217
                        103(E)
        408
                                051(S)
                        099
                                048(R)
                191
                                047(H)
                        092
                                        023(U)
                                045
                                        022(C)
```

### `bmpHuffmCode`

```txt
19: 011010100110010100	1a: 011010100110011			1b: 11110010001011
1c: 0110101001101				1d: 011010100111				1e: 111100100011
1f: 01101010111					20: 11110010011					21: 0110101000
22: 1101101000					23: 001011110						24: 011111111
25: 101110011						26: 00010110						27: 01010110
28: 10100001						29: 11100101						2a: 11111110
2b: 0010100							2c: 0011110							2d: 0101101
2e: 1000010							2f: 1001001							30: 1000000
31: 1001010							32: 1000101							33: 1000011
34: 0111101							35: 0101100							36: 0011100
37: 0010110							38: 0001001							39: 0000011
3a: 11100110						3b: 11100011						3c: 11001001
3d: 10001100						3e: 01110001						3f: 01101100
40: 01001110						41: 00110101						42: 00010111
43: 00011011						44: 00010000						45: 00010001
46: 00110001						47: 00011101						48: 00100111
49: 00011100						4a: 01000010						4b: 01001011
4c: 00110011						4d: 01000011						4e: 01100100
4f: 01100001						50: 01010000						51: 01010111
52: 00110000						53: 01110000						54: 01100010
55: 01111000						56: 01111110						57: 10000010
58: 10100000						59: 10100101						5a: 10101001
5b: 11010110						5c: 11010000						5d: 11110000
5e: 11111101						5f: 0001010							60: 0010001
61: 0100100							62: 0101110							63: 1001100
64: 0111010							65: 0110111							66: 0111011
67: 0101001							68: 0011111							69: 0011011
6a: 0001100							6b: 0000101							6c: 0000010
6d: 11101010						6e: 11110110						6f: 11111010
70: 11110011						71: 11111111						72: 11111001
73: 11101011						74: 11111100						75: 0000001
76: 0000111							77: 0000110							78: 0001111
79: 0100010							7a: 0100011							7b: 0110011
7c: 1000111							7d: 1001011							7e: 1011101
7f: 1011011							80: 1100101							81: 1101111
82: 1100110							83: 1010110							84: 1010101
85: 1001110							86: 0111110							87: 0101111
88: 0111001							89: 0110100							8a: 1000100
8b: 1001111							8c: 1011000							8d: 1010111
8e: 1100001							8f: 1101010							90: 1101100
91: 1101001							92: 1010011							93: 1100000
94: 1011001							95: 1010001							96: 1011110
97: 1011111							98: 1100011							99: 1110100
9a: 1111010							9b: 1110111							9c: 1110110
9d: 1110000							9e: 1100111							9f: 1011010
a0: 1001000							a1: 0101010							a2: 0100000
a3: 0010000							a4: 0000000							a5: 11111011
a6: 11110111						a7: 11100010						a8: 11010001
a9: 11011100						aa: 10111000						ab: 11000101
ac: 11110001						ad: 11011101						ae: 11010111
af: 11000100						b0: 11001000						b1: 11011011
b2: 10101000						b3: 01101101						b4: 01010001
b5: 00100110						b6: 00011010						b7: 111100101
b8: 111001000						b9: 110110101						ba: 111001001
bb: 111110001						bc: 111001110						bd: 111001111
be: 00001000						bf: 00100101						c0: 00101011
c1: 01001111						c2: 01100000						c3: 10000011
c4: 00111010						c5: 00111011						c6: 01001010
c7: 00101010						c8: 00101110						c9: 01001101
ca: 00110010						cb: 00110100						cc: 01001100
cd: 01111001						ce: 01101011						cf: 10011011
d0: 10100100						d1: 10001101						d2: 01100011
d3: 10011010						d4: 01100101						d5: 00100100
d6: 111110000						d7: 101110010						d8: 011111110
d9: 000010010						da: 000010011						db: 1101101001
dc: 0010111111					dd: 0110101010					de: 0010111110
df: 11110010010					e0: 01101010110					e1: 111100100001
e2: 111100100000				e3: 011010100100				e4: 011010100101
e5: 11110010001010			e6: 11110010001001			e7: 111100100010000
e8: 011010100110001			e9: 011010100110000			ea: 111100100010001
eb: 01101010011001000		ee: 011010100110010110	f2: 01101010011001001
f4: 011010100110010101	f5: 011010100110010111
```

### `bmpCodeFile`

> 由于文件太大，不易展示，详细可在附带压缩包中可见

---

